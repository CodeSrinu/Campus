<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Campus Connect — Navigation</title>
  <!-- Leaflet CSS -->
  <!-- Bootstrap 5 CSS and Icons for navbar consistency -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <link href="/static/style.css" rel="stylesheet" />

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <!-- Leaflet Routing Machine -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #0f1720;
      --text: #e6edf3;
      --muted: #94a3b8;
      --mask: rgba(80, 94, 108, 0.65);
      --stroke: rgba(255, 255, 255, 0.9);
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); }
    #app { 
      height: 100%; 
      display: grid; 
      grid-template-columns: 300px 1fr;
      grid-template-rows: auto 1fr;
    }
    
    header { 
      grid-column: 1 / -1;
      padding: 10px 14px; 
      background: var(--panel); 
      border-bottom: 1px solid #1e293b; 
      display: flex; 
      align-items: center; 
      gap: 10px; 
    }
    
    header h1 { 
      font-size: 16px; 
      margin: 0; 
      font-weight: 600; 
      letter-spacing: 0.3px; 
    }
    
    header .sub { 
      font-size: 12px; 
      color: var(--muted); 
    }
    
    #sidebar {
      background: var(--panel);
      border-right: 1px solid #1e293b;
      padding: 20px;
      overflow-y: auto;
      height: 100%;
    }
    
    .sidebar-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      color: var(--text);
      border-bottom: 2px solid #3b82f6;
      padding-bottom: 10px;
    }
    
    .building-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    .building-item {
      margin-bottom: 12px;
    }
    
    .building-btn {
      width: 100%;
      text-align: left;
      padding: 12px 16px;
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid rgba(59, 130, 246, 0.3);
      border-radius: 8px;
      color: var(--text);
      transition: all 0.2s ease;
      cursor: pointer;
    }
    
    .leaflet-interactive {
      transition: fill-opacity 0.3s ease, stroke-width 0.3s ease;
    }
    
    .building-btn:hover {
      background: rgba(59, 130, 246, 0.2);
      border-color: rgba(59, 130, 246, 0.5);
      transform: translateY(-1px);
    }
    
    .building-btn:active {
      transform: translateY(0);
    }
    
    .building-name {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 4px;
    }
    
    .building-category {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    #map { 
      height: 100%; 
      width: 100%; 
    }
    .status { position: absolute; top: 10px; right: 10px; background: rgba(15, 23, 32, 0.9); color: var(--text); padding: 8px 10px; border-radius: 8px; font-size: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.3); z-index: 1000; }
    .error { color: #fecaca; }
    .success { color: #86efac; }
    .leaflet-container { background: #0b0f14; }
    
    .location-status {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(15, 23, 32, 0.95);
      color: var(--text);
      padding: 16px;
      border-radius: 12px;
      font-size: 13px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      z-index: 1000;
      max-width: 280px;
      border: 1px solid rgba(59, 130, 246, 0.3);
      backdrop-filter: blur(4px);
      transition: all 0.3s ease;
    }
    
    .location-status:hover {
      box-shadow: 0 6px 24px rgba(0,0,0,0.5);
      transform: translateY(-2px);
    }
    
    .location-btn {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 12px;
      font-size: 12px;
      font-weight: 500;
      letter-spacing: 0.3px;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
      transition: all 0.2s ease;
      width: 100%;
    }
    
    .location-btn:hover:not(:disabled) {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }
    
    .location-btn:disabled {
      background: #4b5563;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    #clearRouteBtn {
      background: linear-gradient(135deg, #6b7280, #4b5563);
    }
    
    #clearRouteBtn:hover:not(:disabled) {
      background: linear-gradient(135deg, #4b5563, #374151);
    }
    
    .location-status .error {
      color: #f87171;
      font-weight: 500;
    }
    
    .sidebar-toggle {
      display: none;
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1001;
      background: var(--panel);
      border: 1px solid #1e293b;
      color: var(--text);
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
    }
    
    .map-control-btn {
      background: rgba(15, 23, 32, 0.9);
      border: 1px solid #1e293b;
      color: var(--text);
      padding: 10px 12px;
      border-radius: 6px;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
      backdrop-filter: blur(4px);
    }
    
    .map-control-btn:hover {
      background: rgba(25, 35, 45, 0.95);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    }
    
    .map-control-btn:active {
      transform: translateY(0);
    }
    
    .map-control-btn i {
      font-size: 16px;
    }

    .filter-label {
      font-size: 14px;
      color: var(--muted);
      margin-bottom: 8px;
      display: block;
    }

    .category-filter {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #3b82f6;
      border-radius: 6px;
      background-color: var(--panel);
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .category-filter:hover {
      background-color: #1a202c;
      border-color: #63b3ed;
    }

    .category-filter:focus {
      outline: none;
      box-shadow: 0 0 0 2px #63b3ed;
    }
    
    @media (max-width: 768px) {
      #app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
      }
      
      #map {
        margin-top: 50px; /* Space for navbar */
        height: calc(100vh - 50px); /* Full viewport height minus navbar */
      }
      
      /* Compact filter section for mobile */
      #sidebar {
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1000;
        background: var(--panel);
        padding: 15px;
        padding-top: 80px; /* Space for fixed filter section */
        overflow-y: auto;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        display: none;
      }
      
      #sidebar.visible {
        display: block;
      }
      
      .sidebar-toggle {
        display: block !important;
      }
      
      /* Fixed filter section for mobile */
      .filter-section {
        position: fixed;
        top: 65px;
        left: 15px;
        right: 15px;
        background: var(--panel);
        padding: 10px;
        border: 1px solid #1e293b;
        border-radius: 6px;
        z-index: 1002;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }
      
      .filter-label {
        font-size: 12px;
        margin-bottom: 5px;
      }
      
      .category-filter {
        font-size: 14px;
        padding: 6px 10px;
      }
      
      /* Adjust building list for mobile */
      .building-list {
        margin-top: 60px; /* Space for filter section */
      }
      
      .building-btn {
        padding: 12px;
        margin-bottom: 8px;
      }
      
      .building-name {
        font-size: 14px;
      }
      
      .building-category {
        font-size: 11px;
      }
    }
  </style>
</head>
<body class="map-page">
  <!-- Reuse navbar from index for consistency -->
  <nav class="navbar navbar-expand-lg navbar-light bg-light fixed-top border-bottom app-navbar">
    <div class="container-fluid">
      <a class="navbar-brand d-flex align-items-center gap-2" href="/">
        <i class="bi bi-mortarboard-fill icon-primary"></i>
        <span class="fw-semibold">smart campus App</span>
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#mapNav" aria-controls="mapNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="mapNav">
        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
          <li class="nav-item"><a class="nav-link" href="/">Home</a></li>
          <li class="nav-item"><a class="nav-link" href="#map">Map</a></li>
        </ul>
      </div>
    </div>
  </nav>

  <div id="app" class="pt-5 mt-4">
    <header class="px-3">
      <h1>smart campus App — Navigation</h1>
      <div class="sub">Interactive campus map with building navigation</div>
    </header>
    
    <!-- Sidebar Toggle Button for Mobile -->
    <button class="sidebar-toggle" id="sidebarToggle">
      <i class="bi bi-list"></i> Buildings
    </button>
    
    <!-- Sidebar -->
    <div id="sidebar">
      <button class="sidebar-close" id="sidebarClose" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: var(--text); font-size: 20px; cursor: pointer;">&times;</button>
      <div class="sidebar-title">
        <i class="bi bi-building"></i> Campus Buildings
      </div>
      
      <!-- Filter Dropdown (always visible) -->
      <div class="filter-section">
        <label for="categoryFilter" class="filter-label">Filter by Category:</label>
        <select id="categoryFilter" class="category-filter">
          <option value="">All Categories</option>
          <option value="Academic">Academic</option>
          <option value="Admin">Admin</option>
          <option value="Facility">Facility</option>
          <option value="Hostel">Hostel</option>
          <option value="Sports">Sports</option>
          <option value="General">General</option>
        </select>
      </div>
      
      <ul class="building-list" id="buildingList">
        <!-- Buildings will be populated dynamically -->
      </ul>
    </div>
    
    <!-- Map Container -->
    <div id="map" class="map-container">
      <!-- Floating filter button on map for mobile quick access -->
      <button class="sidebar-toggle" id="mapFilterToggle" style="position: absolute; top: 10px; right: 10px; z-index: 999; display: none;">
        <i class="bi bi-funnel"></i> Filter
      </button>
      
      <!-- Re-center button -->
      <button id="recenterBtn" class="map-control-btn" title="Re-center to your location" style="position: absolute; bottom: 20px; right: 20px; z-index: 1000; display: none;">
        <i class="bi bi-crosshair"></i>
      </button>
    </div>
    
    <!-- Location Status -->
    <div class="location-status">
      <div><strong><i class="bi bi-geo-alt-fill"></i> Location Tracker</strong></div>
      <div id="locationText">Click to enable real-time location tracking</div>
      <button class="location-btn" id="locationBtn">Enable Location</button>
      <button class="location-btn" id="clearRouteBtn" style="margin-top: 8px;">Clear Route</button>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <!-- Leaflet Routing Machine -->
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
  <script>
    // API Base URL
    const API_BASE = 'https://campus-xqcw.onrender.com';
    
    // Utility function for API calls
    async function apiCall(endpoint, options = {}) {
      const url = `${API_BASE}${endpoint}`;
      return await fetch(url, options);
    }

    (async function init() {

      // Fetch campus boundary data from backend
      let campusBoundary = null;
      try {
        const res = await apiCall('/api/campus/boundary');
        if (!res.ok) throw new Error('Network response was not ok');
        campusBoundary = await res.json();
        console.log('Loaded campus boundary:', campusBoundary);
      } catch (err) {
        console.error('Campus boundary fetch failed:', err);
      }

      // Fetch building data from backend
      let buildings = [];
      try {
        const res = await apiCall('/api/locations');
        if (!res.ok) throw new Error('Network response was not ok');
        const data = await res.json();
        buildings = Array.isArray(data) ? data : [];
        console.log('Loaded buildings:', buildings);
        statusEl.textContent = `Loaded ${buildings.length} buildings`;
        statusEl.classList.add('success');
      } catch (err) {
        statusEl.textContent = 'Failed to load buildings from backend.';
        statusEl.classList.add('error');
        console.error('Buildings fetch failed:', err);
        return;
      }

      // Initialize Leaflet map
      const map = L.map('map', { 
        preferCanvas: true, 
        zoomControl: true,
        center: [16.83, 81.53], // Default center for NIT campus
        zoom: 17
      });

      // Professional basemap
      const tiles = L.tileLayer(
        'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
        {
          attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
          maxZoom: 20,
          noWrap: true
        }
      ).addTo(map);

      // Create panes for layering
      map.createPane('buildings');
      map.getPane('buildings').style.zIndex = 400;

      // Store building references for interaction
      const buildingLayers = new Map();
      const buildingListEl = document.getElementById('buildingList');

      // Draw buildings and bind popups
      console.log('Starting to draw buildings:', buildings.length);
      buildings.forEach((building, index) => {
        const coords = building.coordinates || [];
        console.log(`Building ${index + 1}:`, building.name, 'Coords:', coords.length, 'points');
        if (coords.length < 3) {
          console.log(`Skipping building ${index + 1}: not enough coordinates`);
          return;
        }

        const name = building.name || `Building ${index + 1}`;
        const description = building.description || 'No description available';
        const category = building.category || 'General';
        const imageUrl = building.imageUrl || 'https://placehold.co/300x200?text=Building';

        // Create building polygon with visible borders and shadow effect
        // Shadow layer (drawn first to appear behind)
        const shadowPolygon = L.polygon(coords, {
          pane: 'buildings',
          color: 'rgba(0, 0, 0, 0.3)',
          weight: 4,
          opacity: 0.4,
          fillColor: 'rgba(0, 0, 0, 0.15)',
          fillOpacity: 0.2,
          interactive: false // Shadow doesn't respond to mouse events
        }).addTo(map);
        
        // Main building layer (drawn on top of shadow)
        const buildingPolygon = L.polygon(coords, {
          pane: 'buildings',
          color: '#ffffff',
          weight: 2,
          opacity: 1,
          fillColor: getCategoryColor(category),
          fillOpacity: 0.85
        }).addTo(map);
        
        console.log(`Created polygon for ${name}:`, buildingPolygon.getBounds());

        // Create popup content
        const popupContent = `
          <div style="min-width: 250px; max-width: 280px;">
            <div style="text-align: center; margin-bottom: 15px;">
              <img src="${imageUrl}" alt="${name}" style="width: 100%; height: 150px; object-fit: cover; border-radius: 8px;">
            </div>
            <h4 style="margin: 0 0 10px 0; color: #1f2937;">${escapeHtml(name)}</h4>
            <p style="margin: 0 0 10px 0; color: #6b7280; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; background-color: ${getCategoryColor(category)}; display: inline-block; padding: 4px 8px; border-radius: 4px; color: #000;">
              ${escapeHtml(category)}
            </p>
            <p style="margin: 0; color: #374151; line-height: 1.5;">
              ${escapeHtml(description)}
            </p>
            <div style="margin-top: 15px; text-align: center;">
              <button class="btn btn-primary btn-sm view-3d-btn" data-building-id="${building.id || name}" data-building-name="${escapeHtml(name)}">
                <i class="bi bi-box"></i> View in 3D
              </button>
            </div>
          </div>
        `;

        buildingPolygon.bindPopup(popupContent);

        // Store reference for interaction (store both shadow and main building)
        buildingLayers.set(name, {
          shadow: shadowPolygon,
          main: buildingPolygon
        });

        // Add click event to building polygon
        buildingPolygon.on('click', () => {
          routeToBuilding(name);
        });

        // Create sidebar button
        const buildingItem = document.createElement('li');
        buildingItem.className = 'building-item';
        buildingItem.innerHTML = `
          <button class="building-btn" data-building="${name}">
            <div class="building-name">${escapeHtml(name)}</div>
            <div class="building-category">${escapeHtml(category)}</div>
          </button>
        `;

        // Add click event to sidebar button
        buildingItem.querySelector('.building-btn').addEventListener('click', () => {
          routeToBuilding(name);
        });

        // Add hover effect to building polygon
        buildingPolygon.on('mouseover', () => {
          buildingPolygon.setStyle({ fillOpacity: 0.95, weight: 3 });
        });
        
        buildingPolygon.on('mouseout', () => {
          buildingPolygon.setStyle({ fillOpacity: 0.85, weight: 2 });
        });

        buildingListEl.appendChild(buildingItem);
      });

      // Function to handle building routing
      function routeToBuilding(buildingName) {
        const buildingLayer = buildingLayers.get(buildingName);
        if (!buildingLayer) return;
        
        // Get the center of the building as the destination
        const destination = buildingLayer.main.getBounds().getCenter();
        
        // First, zoom to the building and show its popup with smooth easing
        const bounds = buildingLayer.main.getBounds();
        map.flyToBounds(bounds, { 
          duration: 1.2,
          padding: [50, 50],
          animate: true,
          easeLinearity: 0.2
        });
        
        // Open popup with a slight delay for better visual flow
        setTimeout(() => {
          buildingLayer.main.openPopup();
        }, 1000);
        
        // After showing the building, calculate and display the route with smooth transitions
        setTimeout(() => {
          // If routing control already exists, remove it with fade out
          if (routingControl) {
            // Try to fade out existing route
            try {
              const routeLines = document.querySelectorAll('.leaflet-routing-line');
              routeLines.forEach(line => {
                line.style.transition = 'opacity 0.3s ease';
                line.style.opacity = '0';
              });
            } catch (e) {
              // Fallback if we can't access the route lines directly
            }
            
            // Remove after fade
            setTimeout(() => {
              if (routingControl) {
                map.removeControl(routingControl);
                routingControl = null;
              }
            }, 300);
          }
          
          // Get user's current location
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              (position) => {
                const userLocation = L.latLng(position.coords.latitude, position.coords.longitude);
                
                // Create new routing control with shortest path algorithm
                routingControl = L.Routing.control({
                  waypoints: [
                    userLocation,
                    destination
                  ],
                  routeWhileDragging: false,
                  show: false, // Hide the instruction panel
                  createMarker: function() { return null; }, // Don't create markers
                  lineOptions: {
                    styles: [
                      {color: '#ffffff', opacity: 0.8, weight: 6}, // White outline
                      {color: '#4b0082', opacity: 0.8, weight: 4}  // Purple route
                    ]
                  },
                  router: L.Routing.osrmv1({
                    serviceUrl: 'https://router.project-osrm.org/route/v1',
                    profile: 'walking', // Use walking for shortest path on campus
                    suppressDemoServerWarning: true
                  }),
                  fitSelectedRoutes: false, // We'll handle fitting manually for better control
                  autoRoute: true
                });
                
                // Add routing control to map
                routingControl.addTo(map);
                
                // Smoothly fit the map to show both the route and building with easing
                setTimeout(() => {
                  if (routingControl) {
                    const routeBounds = L.latLngBounds([userLocation, destination]);
                    map.flyToBounds(routeBounds, {
                      duration: 1.8,
                      padding: [100, 100],
                      animate: true,
                      easeLinearity: 0.25
                    });
                  }
                }, 600);
              },
              (error) => {
                console.error('Geolocation error:', error);
              },
              {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 300000
              }
            );
          }
        }, 2200); // Wait 2.2 seconds after showing the building before showing the route
      }

      // Category filter functionality
      const categoryFilter = document.getElementById('categoryFilter');
      if (categoryFilter) {
        categoryFilter.addEventListener('change', () => {
          const selectedCategory = categoryFilter.value;
          const buildingItems = buildingListEl.querySelectorAll('.building-item');
          
          buildingItems.forEach((item, index) => {
            const building = buildings[index];
            if (!building) return;
            
            if (!selectedCategory || building.category === selectedCategory) {
              item.style.display = 'block';
              // Show building on map
              const buildingLayer = buildingLayers.get(building.name);
              if (buildingLayer) {
                if (buildingLayer.shadow) {
                  buildingLayer.shadow.setStyle({ opacity: 0.4, fillOpacity: 0.2 });
                }
                if (buildingLayer.main) {
                  buildingLayer.main.setStyle({ opacity: 1, fillOpacity: 0.85 });
                }
              }
            } else {
              item.style.display = 'none';
              // Hide building on map
              const buildingLayer = buildingLayers.get(building.name);
              if (buildingLayer) {
                if (buildingLayer.shadow) {
                  buildingLayer.shadow.setStyle({ opacity: 0.1, fillOpacity: 0.05 });
                }
                if (buildingLayer.main) {
                  buildingLayer.main.setStyle({ opacity: 0.2, fillOpacity: 0.1 });
                }
              }
            }
          });
        });
      }
      
      // Sidebar toggle for mobile
      const sidebarToggle = document.getElementById('sidebarToggle');
      const mapFilterToggle = document.getElementById('mapFilterToggle');
      const sidebarClose = document.getElementById('sidebarClose');
      const sidebar = document.getElementById('sidebar');

      // Draw campus boundary if available
      let boundaryLayer = null;
      if (campusBoundary && campusBoundary.coordinates && campusBoundary.coordinates.length > 0) {
        // Create a world polygon with a hole for the campus (creates a dimming effect outside)
        const worldBounds = [[-90, -180], [90, -180], [90, 180], [-90, 180]];
        // Create polygon with hole - world bounds as outer ring, campus boundary as inner ring (hole)
        const maskingPolygon = L.polygon([worldBounds, campusBoundary.coordinates], {
          color: 'transparent',
          fillColor: '#000000', // Black fill
          fillOpacity: 0.25, // Subtle dimming effect
          weight: 0,
          interactive: false // Disable interactions
        }).addTo(map);
        
        // Create the campus boundary with a subtle dark border
        boundaryLayer = L.polygon(campusBoundary.coordinates, {
          color: '#333333', // Dark gray border with less intensity
          weight: 2, // Thinner border
          opacity: 0.7, // Less intense
          fillColor: 'transparent',
        }).addTo(map);
        
        console.log('Campus boundary drawn:', campusBoundary.coordinates.length, 'points');
      }

      // Draw roads if available
      let roadsLayer = null;
      try {
        const roadsRes = await apiCall('/api/roads');
        if (roadsRes.ok) {
          const roadsData = await roadsRes.json();
          console.log('Loaded roads:', roadsData);
          
          // Create a separate pane for roads to control layering
          map.createPane('roads');
          map.getPane('roads').style.zIndex = 350; // Between background and buildings
          
          // Draw each road as a subtle gray line
          roadsData.forEach((road, index) => {
            if (road.coordinates && road.coordinates.length > 0) {
              const roadLine = L.polyline(road.coordinates, {
                pane: 'roads',
                color: '#888888', // Light darkish gray color
                weight: 2, // Thin line as requested
                opacity: 0.6, // More subtle
                smoothFactor: 1
              }).addTo(map);
              
              // Add popup with road name if available
              if (road.name) {
                roadLine.bindPopup(`<b>Road</b><br>${escapeHtml(road.name)}`);
              }
            }
          });
          
          console.log(`Drawn ${roadsData.length} roads on map`);
        }
      } catch (err) {
        console.error('Roads fetch failed:', err);
      }

      // Fit map to show all buildings with proper padding
      if (buildings.length > 0) {
        const bounds = L.latLngBounds([]);
        buildings.forEach(building => {
          if (building.coordinates && building.coordinates.length > 0) {
            bounds.extend(building.coordinates);
          }
        });
        if (bounds.isValid()) {
          map.fitBounds(bounds.pad(0.2));
        }
      }
      
      if (sidebarToggle && sidebar) {
        sidebarToggle.addEventListener('click', () => {
          sidebar.classList.toggle('visible');
        });
        
        if (sidebarClose) {
          sidebarClose.addEventListener('click', () => {
            sidebar.classList.remove('visible');
          });
        }
        
        // Close sidebar when clicking on a building
        document.addEventListener('click', (e) => {
          if (e.target.closest('.building-btn') && sidebar.classList.contains('visible')) {
            // Give time for the building to be selected before closing
            setTimeout(() => {
              sidebar.classList.remove('visible');
            }, 500);
          }
        });
      }
      
      // Map filter button for quick access
      if (mapFilterToggle) {
        mapFilterToggle.addEventListener('click', () => {
          if (sidebar) {
            sidebar.classList.toggle('visible');
          }
        });
      }
      
      // Show/hide map filter button based on screen size
      function updateFilterButtonVisibility() {
        if (mapFilterToggle) {
          if (window.innerWidth <= 768) {
            mapFilterToggle.style.display = 'block';
          } else {
            mapFilterToggle.style.display = 'none';
            // Hide sidebar on desktop
            if (sidebar) {
              sidebar.classList.remove('visible');
            }
          }
        }
      }
      
      // Initial check
      updateFilterButtonVisibility();
      
      // Update on resize
      window.addEventListener('resize', updateFilterButtonVisibility);

      // Live location tracking with smooth movement
      let userMarker = null;
      let watchId = null;
      let isTracking = false;
      let lastKnownLocation = null; // Store the user's last known coordinates
      
      const locationBtn = document.getElementById('locationBtn');
      const locationText = document.getElementById('locationText');
      const clearRouteBtn = document.getElementById('clearRouteBtn');

      // Function to smoothly move the marker
      function moveMarkerSmoothly(marker, newLatLng) {
        if (!marker) return;
        
        const currentLatLng = marker.getLatLng();
        const frames = 30; // Number of animation frames
        const deltaLat = (newLatLng.lat - currentLatLng.lat) / frames;
        const deltaLng = (newLatLng.lng - currentLatLng.lng) / frames;
        
        let frame = 0;
        const animate = () => {
          if (frame < frames) {
            const intermediateLat = currentLatLng.lat + deltaLat * frame;
            const intermediateLng = currentLatLng.lng + deltaLng * frame;
            marker.setLatLng([intermediateLat, intermediateLng]);
            frame++;
            requestAnimationFrame(animate);
          } else {
            marker.setLatLng(newLatLng); // Ensure final position
          }
        };
        animate();
      }

      if (locationBtn && locationText) {
        locationBtn.addEventListener('click', () => {
          if (!isTracking) {
            // Start tracking
            if (navigator.geolocation) {
              locationBtn.disabled = true;
              locationBtn.textContent = 'Enabling...';
              locationText.textContent = 'Requesting location access...';
              locationText.classList.remove('error');

              // Watch user position
              watchId = navigator.geolocation.watchPosition(
                (position) => {
                  const { latitude, longitude } = position.coords;
                  
                  // Store the last known location
                  lastKnownLocation = L.latLng(latitude, longitude);
                  
                  if (!userMarker) {
                    // Create user marker with a pulsing effect
                    userMarker = L.circleMarker([latitude, longitude], {
                      radius: 10,
                      fillColor: '#3b82f6',
                      color: '#ffffff',
                      weight: 2,
                      fillOpacity: 0.8,
                      className: 'user-location-marker'
                    }).addTo(map);

                    // Add pulsing animation with CSS
                    const style = document.createElement('style');
                    style.innerHTML = `
                      .user-location-marker {
                        animation: pulse 2s infinite;
                      }
                      @keyframes pulse {
                        0% {
                          transform: scale(1);
                          opacity: 0.8;
                        }
                        50% {
                          transform: scale(1.2);
                          opacity: 0.6;
                        }
                        100% {
                          transform: scale(1);
                          opacity: 0.8;
                        }
                      }
                    `;
                    document.head.appendChild(style);

                    // Add popup to user marker
                    userMarker.bindPopup(`
                      <div style="text-align: center;">
                        <strong>Your Location</strong><br>
                        <small>Lat: ${latitude.toFixed(6)}<br>Lng: ${longitude.toFixed(6)}</small>
                      </div>
                    `);
                  } else {
                    // Update existing marker position smoothly
                    moveMarkerSmoothly(userMarker, [latitude, longitude]);
                  }

                  // Update location text
                  locationText.textContent = `Tracking active - Lat: ${latitude.toFixed(4)}, Lng: ${longitude.toFixed(4)}`;
                  locationText.classList.remove('error');
                  locationBtn.textContent = 'Disable Location';
                  locationBtn.disabled = false;
                  isTracking = true;
                  
                  // Show re-center button when we have a location
                  const recenterBtn = document.getElementById('recenterBtn');
                  if (recenterBtn) {
                    recenterBtn.style.display = 'block';
                  }
                },
                (error) => {
                  console.error('Geolocation error:', error);
                  locationText.textContent = `Location error: ${error.message}`;
                  locationText.classList.add('error');
                  locationBtn.textContent = 'Retry';
                  locationBtn.disabled = false;
                  isTracking = false;
                },
                {
                  enableHighAccuracy: true,
                  timeout: 10000,
                  maximumAge: 5000 // More frequent updates
                }
              );
            } else {
              locationText.textContent = 'Geolocation not supported by your browser';
              locationText.classList.add('error');
              locationBtn.disabled = true;
              isTracking = false;
            }
          } else {
              // Stop tracking
              if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
              }
              
              if (userMarker) {
                map.removeLayer(userMarker);
                userMarker = null;
              }
              
              // Clear last known location and hide re-center button
              lastKnownLocation = null;
              const recenterBtn = document.getElementById('recenterBtn');
              if (recenterBtn) {
                recenterBtn.style.display = 'none';
              }
              
              locationText.textContent = 'Location tracking disabled';
              locationBtn.textContent = 'Enable Location';
              isTracking = false;
            }
        });
      }

      // Add event listener for clear route button
      if (clearRouteBtn) {
        clearRouteBtn.addEventListener('click', () => {
          clearRoute();
        });
      }

      // Add event listener for re-center button
      const recenterBtn = document.getElementById('recenterBtn');
      if (recenterBtn) {
        recenterBtn.addEventListener('click', () => {
          if (lastKnownLocation) {
            map.flyTo(lastKnownLocation, map.getZoom(), {
              animate: true,
              duration: 1.5,
              easeLinearity: 0.25
            });
          }
        });
      }

      // Add event listener for 3D view buttons (using event delegation)
      document.addEventListener('click', function(e) {
        if (e.target.closest('.view-3d-btn')) {
          const button = e.target.closest('.view-3d-btn');
          const buildingId = button.getAttribute('data-building-id');
          const buildingName = button.getAttribute('data-building-name');
          
          // Create placeholder content for 3D view
          const content = `
            <div class="text-center p-4">
              <h3><i class="bi bi-box"></i> 3D View of ${escapeHtml(buildingName)}</h3>
              <div class="mt-4">
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; height: 400px; display: flex; align-items: center; justify-content: center; color: white;">
                  <div>
                    <i class="bi bi-building" style="font-size: 4rem;"></i>
                    <p class="mt-3" style="font-size: 1.2rem;">Interactive 3D Model of ${escapeHtml(buildingName)}</p>
                    <p class="mt-2" style="opacity: 0.8;">This is a placeholder for a future 3D visualization feature.</p>
                    <div class="mt-4">
                      <button class="btn btn-light me-2"><i class="bi bi-arrow-clockwise"></i> Rotate</button>
                      <button class="btn btn-light me-2"><i class="bi bi-zoom-in"></i> Zoom</button>
                      <button class="btn btn-light"><i class="bi bi-fullscreen"></i> Fullscreen</button>
                    </div>
                  </div>
                </div>
                <div class="mt-3 text-muted">
                  <small><i class="bi bi-info-circle"></i> In a full implementation, this would show an interactive 3D model of the building.</small>
                </div>
              </div>
            </div>
          `;
          
          // Insert content into modal
          const modalContent = document.getElementById('modal-3d-content');
          if (modalContent) {
            modalContent.innerHTML = content;
          }
          
          // Open Bootstrap modal
          const modal = new bootstrap.Modal(document.getElementById('modal3DView'));
          modal.show();
        }
      });

      // Utility functions
      function getCategoryColor(category) {
        const colors = {
          'Academic': '#00C853', // academic zone (vibrant green)
          'Admin': '#FF6D00', // administrative zone (vibrant orange)
          'Facility': '#FF1744', // student activity zone (vibrant red)
          'Hostel': '#2979FF', // hostel zone (vibrant blue)
          'Sports': '#FFD600', // sports zone (vibrant yellow)
          'Residential': '#D500F9', // residential zone (vibrant purple)
          'Other': '#FF4081', // other buildings (vibrant pink)
          'General': '#64FFDA', // bulk service zone (vibrant teal)
          'Parking': '#76FF03' // parking (vibrant lime)
        };
        return colors[category] || colors['General'];
      }
      
      function getUniqueBuildingColor(name) {
        // Simple hash function to generate consistent colors for each building name
        let hash = 0;
        for (let i = 0; i < name.length; i++) {
          hash = name.charCodeAt(i) + ((hash << 5) - hash);
        }
        
        // Use a large palette of vibrant, non-pink colors
        const colorPalette = [
          '#FF5722', // Deep Orange
          '#FF9800', // Orange
          '#FFC107', // Amber
          '#FFEB3B', // Yellow
          '#CDDC39', // Lime
          '#8BC34A', // Light Green
          '#4CAF50', // Green
          '#009688', // Teal
          '#00BCD4', // Cyan
          '#03A9F4', // Light Blue
          '#2196F3', // Blue
          '#3F51B5', // Indigo
          '#673AB7', // Deep Purple
          '#9C27B0', // Purple
          '#00E676', // Vibrant Green (replaced pink)
          '#795548', // Brown
          '#607D8B', // Blue Grey
          '#FF9E80', // Light Orange
          '#CDFFCC', // Light Green
          '#B39DDB'  // Light Purple
        ];
        
        // Select color based on hash
        const index = Math.abs(hash) % colorPalette.length;
        return colorPalette[index];
      }

      function escapeHtml(str) {
        return String(str).replace(/[&<>"]/g, s => ({
          '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;'
        })[s]);
      }

      // Clean up status message
      setTimeout(() => {
        if (statusEl.parentNode) {
          statusEl.remove();
        }
      }, 3000);

    })();
  </script>
  
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
  
  <!-- 3D View Modal -->
  <div class="modal fade" id="modal3DView" tabindex="-1" aria-labelledby="modal3DViewLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="modal3DViewLabel">3D Building View</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div id="modal-3d-content">
            <!-- 3D content will be loaded here -->
            <div class="d-flex justify-content-center align-items-center" style="height: 400px;">
              <div class="text-center">
                <div class="spinner-border text-primary" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
                <p class="mt-2">Loading 3D view...</p>
              </div>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>
</body>
</html>